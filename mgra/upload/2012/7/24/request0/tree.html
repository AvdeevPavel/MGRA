<!DOCTYPE html><html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>MGRA tree</title><style type="text/css">
	                .end0{color:green}
	                .end1{color:red}
	                .end2{color:lime}
	                .end3{color:maroon}
	            </style><script src="http://www.kineticjs.com/download/kinetic-v3.10.4.js"></script><script>
                	var values =  [
               	    	
		'MR',
	
		'DOQHC',
	
		'M',
	
		'R',
	
		'MRDO',
	
		'QHC',
	
		'Q',
	
		'HC',
	
		'H',
	
		'C',
	
                	]
					
					var trees = [ 
						
		[
			
        	[
				
			{	
				viewRect: null, 
				lines: null,
		  		leftChildNumber: 0,
				rightChildNumber: 1,
				text: "MR"
			},
    
			{	
				viewRect: null, 
				lines: null,
		  		leftChildNumber: -1,
				rightChildNumber: -1,
				text: "DOQHC"
			},
    
			],
    
        	[
				
			{	
				viewRect: null, 
				lines: null,
		  		leftChildNumber: -1,
				rightChildNumber: -1,
				text: "M"
			},
    
			{	
				viewRect: null, 
				lines: null,
		  		leftChildNumber: -1,
				rightChildNumber: -1,
				text: "R"
			},
    
			],
    
		], 
    
		[
			
        	[
				
			{	
				viewRect: null, 
				lines: null,
		  		leftChildNumber: -1,
				rightChildNumber: -1,
				text: "MRDO"
			},
    
			{	
				viewRect: null, 
				lines: null,
		  		leftChildNumber: 0,
				rightChildNumber: 1,
				text: "QHC"
			},
    
			],
    
        	[
				
			{	
				viewRect: null, 
				lines: null,
		  		leftChildNumber: -1,
				rightChildNumber: -1,
				text: "Q"
			},
    
			{	
				viewRect: null, 
				lines: null,
		  		leftChildNumber: 0,
				rightChildNumber: 1,
				text: "HC"
			},
    
			],
    
        	[
				
			{	
				viewRect: null, 
				lines: null,
		  		leftChildNumber: -1,
				rightChildNumber: -1,
				text: "H"
			},
    
			{	
				viewRect: null, 
				lines: null,
		  		leftChildNumber: -1,
				rightChildNumber: -1,
				text: "C"
			},
    
			],
    
		], 
    
					]

					function getClientWidth() {
						return document.compatMode=='CSS1Compat' && !window.opera?document.documentElement.clientWidth:document.body.clientWidth;
					}
		
					function getClientHeight() {
						return document.compatMode=='CSS1Compat' && !window.opera?document.documentElement.clientHeight:document.body.clientHeight;
					}
					
					function changeStyle(id, show){
	                    var element = document.getElementById(id);
	                    if (element != null) {
	                        element.style.display= id == show ? "" : "none";;
	                    }
	                }

					function createStage(nameContainer, width_, height_) {	
						var stage = new Kinetic.Stage({ 
							container: nameContainer,
							width: width_,  
							height: height_
						});
						stage.on("mouseup", function() {
          					document.body.style.cursor = "default";
        				});
						return stage; 		 
					} 	
			
					function createText(str, color, coorX, coorY, layer) { 
						var text = new Kinetic.Text({
							text: str,	
							x: coorX,
							y: coorY,
							cornerRadius: 5,
							stroke: "black",
							strokeWidth: 2,
							fill: color,
							fontSize: 13,
							padding: 13, 
							fontFamily: "Calibri",
							textFill: "black",
							align: 'center',
							fontStyle: 'italic',
							shadow: {
								color: 'black',
								blur: 1,
								offset: [10, 10],
								alpha: 0.2
							}
		  				});
						text.on("mouseover", function() { 
							this.setDraggable(true);
							this.setFill("blue");
							layer.draw();
						});	
						text.on("mouseout", function() { 
							this.setDraggable(false);
							var element = document.getElementById('gen'+str);
	                    	if (element != null) {
								this.setFill("yellow");
	                 		} else {
								this.setFill("#00dddd");
							}
							layer.draw();
						});	

						text.on("mousedown", function() {
			          		document.body.style.cursor = "pointer";
			        	});

						text.on("dblclick", function(evt) { 
							for (var i = 0; i < values.length; ++i) {
	                        	changeStyle('trs'+values[i], 'trs'+str);
	                        	changeStyle('gen'+values[i], 'gen'+str);
	                    	}	
						});
						return text;  
					}

					function createLine(x1, y1, x2, y2) { 
						var line = new Kinetic.Line({
							points: [{x: x1, y: y1} , {x: x2, y: y2}],
							stroke: "black", 
							lineCap: "round",
							lineJoin: "round", 
							strokeWidth: 3,
						});
						return line;
					} 
		
					function createEventDrag(rect, lines, layer) { 
						rect.on("dragmove dragend", function() {
							if (lines[0] != null)
								lines[0].attrs.points[1] ={x:(this.getX()+this.getBoxWidth() / 2), y:this.getY()};				
							if (lines[1] != null)		
								lines[1].attrs.points[0] ={x:(this.getX()+this.getBoxWidth() / 2), y:(this.getY()+this.getBoxHeight())};
							if (lines[2] != null)	
								lines[2].attrs.points[0] ={x:(this.getX()+this.getBoxWidth() / 2), y:(this.getY()+this.getBoxHeight())};						
							layer.draw();
    	    			});
					} 

 					function createNodes(k, stage, layer) {
 						var stepHeight = stage.getHeight() / (trees[k].length + 1); 
						var countInLevel = 2; 

						for(var i = 0; i < trees[k].length; ++i) { 
							countInLevel = countInLevel * 2;
							var stepWidth = 1; 
							for(var j = 0; j < trees[k][i].length; ++j) { 
								var element = document.getElementById('gen'+trees[k][i][j].text);
	                    		if (element != null) {
										trees[k][i][j].viewRect = createText(trees[k][i][j].text, "yellow", stepWidth * stage.getWidth() / countInLevel, stepHeight + i * stepHeight, layer);
								} else { 
										trees[k][i][j].viewRect = createText(trees[k][i][j].text, "#00dddd", stepWidth * stage.getWidth() / countInLevel, stepHeight + i * stepHeight, layer);
								} 
								stepWidth += 2;								
							}
						} 
					}

					function createEdge(k, stage) { 

						for(var i = 0; i < trees[k].length; ++i) { 
							for(var j = 0; j < trees[k][i].length; ++j) { 
								trees[k][i][j].lines = new Array(3);
							} 
						}
			
						trees[k][0][0].lines[0] = createLine(stage.getWidth() / 2, 5, (trees[k][0][0].viewRect.getX() + trees[k][0][0].viewRect.getBoxWidth() / 2), trees[k][0][0].viewRect.getY());
						trees[k][0][1].lines[0] = createLine(stage.getWidth() / 2, 5, (trees[k][0][1].viewRect.getX() + trees[k][0][1].viewRect.getBoxWidth() / 2), trees[k][0][1].viewRect.getY());
		
						for(var i = 0; i < trees[k].length; ++i) { 
							for(var j = 0; j < trees[k][i].length; ++j) {
								var x1 = trees[k][i][j].viewRect.getX() + trees[k][i][j].viewRect.getBoxWidth() / 2;
								var y1 = trees[k][i][j].viewRect.getY() + trees[k][i][j].viewRect.getBoxHeight(); 

								if (trees[k][i][j].leftChildNumber != -1) { 
									var x2 = trees[k][i + 1][trees[k][i][j].leftChildNumber].viewRect.getX() + trees[k][i + 1][trees[k][i][j].leftChildNumber].viewRect.getBoxWidth() / 2; 
									var y2 = trees[k][i + 1][trees[k][i][j].leftChildNumber].viewRect.getY(); 
									trees[k][i][j].lines[1] = createLine(x1, y1, x2, y2);								
									trees[k][i + 1][trees[k][i][j].leftChildNumber].lines[0] = trees[k][i][j].lines[1]; 
								} 
								
								if (trees[k][i][j].rightChildNumber != -1) { 
									var x2 = trees[k][i + 1][trees[k][i][j].rightChildNumber].viewRect.getX() + trees[k][i + 1][trees[k][i][j].leftChildNumber].viewRect.getBoxWidth() / 2; 
									var y2 = trees[k][i + 1][trees[k][i][j].rightChildNumber].viewRect.getY(); 
									trees[k][i][j].lines[2] = createLine(x1, y1, x2, y2);
									trees[k][i + 1][trees[k][i][j].rightChildNumber].lines[0] = trees[k][i][j].lines[2]; 
								}
							} 
						} 					
					} 

					function main(k, stage, layer) { 
						createNodes(k, stage, layer); 
						createEdge(k, stage);

						for(var i = 0; i < trees[k].length; ++i) { 
							for(var j = 0; j < trees[k][i].length; ++j) { 
								layer.add(trees[k][i][j].viewRect);
							} 
						}
			
						for(var i = 0; i < trees[k].length; ++i) { 
							for(var j = 0; j < trees[k][i].length; ++j) { 
								createEventDrag(trees[k][i][j].viewRect, trees[k][i][j].lines, layer);
							} 
						}					

						for(var i = 0; i < trees[k].length - 1; ++i) { 
							for(var j = 0; j < trees[k][i].length; ++j) { 
								for(var c = 0; c < trees[k][i][j].lines.length; ++c) { 
									if (trees[k][i][j].lines[c] != null) { 
										layer.add(trees[k][i][j].lines[c]);
									} 
								} 
							} 
						}
					} 

					window.onload = function() {
						
			var stage = createStage("tree0", 99 * getClientWidth() / 100,  getClientHeight() / 2);
			var layer = new Kinetic.Layer();
			main(0, stage, layer);
			stage.add(layer);
    
			var stage = createStage("tree1", 99 * getClientWidth() / 100,  getClientHeight() / 2);
			var layer = new Kinetic.Layer();
			main(1, stage, layer);
			stage.add(layer);
    
    				};
				</script></head>
   <body>
      <h1>
         <center> MGRA TREE, beta version </center>
      </h1>
      <div id="tree0"></div>
      <div id="tree1"></div>
      <footer>
         <hr>
         				MGRA 1.0 Â© 2008,09 by Max Alekseyev
         				
      </footer>
   </body>
</html>