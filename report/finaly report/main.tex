\documentclass{article}

\usepackage{geometry} % пакет для установки полей
\geometry{top=1cm} % отступ сверху
\geometry{bottom=2cm} % отступ снизу
\geometry{left=1cm} % отступ справа
\geometry{right=1cm} % отступ слева

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}

\pagestyle{empty}

\begin{document}

\section{Состояние MGRA-сервера до начала стажировки:}
\begin{enumerate}
	\item MGRA-сервер корректно работал на одном из четырех примеров. 
	\item Данные, загружаемые пользователем, не давали корректного результата. 
	\item Интерфейс был сыроват и непонятен для работы пользователей. 
	\item Деревья имели выделенные корни, которые биологического смысла не несли. 
	\item Содержались ошибки в отображении информации о геноме и трансформации (номера хромосом, спецсимволы).
\end{enumerate}
 

\section{Действия в течение двух месяцев:}
\begin{enumerate}
	\item Были прочитаны статьи и получено представление об области в целом. \\
		http://genome.cshlp.org/content/19/5/943.full.pdf \\
		http://genome.cshlp.org/content/13/1/37.short \\
		http://www.biomedcentral.com/1471-2164/13/129 
	\item Было добавлено три новых примера с данными для работы с MGRA. 
	\item Были найдены и исправлены баги, чтобы сервер заработал на всех, теперь уже шести-семи, примерах. 
	\item Представление деревьев было переделано с таблиц на двоичные деревья. 
	\item Был убран корневой корень и добавлено преобразование трансформаций. 
	\item Была добавлена возможность отображения геномов в виде изображений с учетом размера, если блоки введены в формате «infercars».
	\item Была добавлена возможность отображения перестановок из трансформаций в виде изображения. 
	\item Была добавлена возможность отображения реконструированных деревьев на основе данных, которые выдал mgra tool. 
	\item Была добавлена возможность отображения текущих введенных деревьев. 
	\item Было добавлено небольшое количество проверок на валидность введенных данных. 
	\item Была добавлена возможность загрузки полученных текстовых файлов с геномами и трансформациями, выданными mgra tool. 
	\item Была добавлена возможность загрузки конфигурационного файла и файла с исходными геномами. 
	\item Была добавлена возможность загрузки полученных изображений с сервера.
	\item Была изменена логика работы сервера. \\
		До этого обработка всех данных происходила один раз, и на выходе генерировался статический html. \\  
		Теперь на первом этапе происходит генерация страницы, отображающей дерево. Если существует информация о геномах и трансформациях, соответствующие узлы и ребра дерева подсвечиваются. При нажатии на них происходит событие, которое приводит к генерации соответствующей информации.
	\item Был полностью переписан интерфейс страницы для ввода данных. 	
	\item Было начато написание отчета для Максима Алексеева. 
\end{enumerate}

\section{Результат:}
MGRA server представляет интерфейс для работы с mgra tool.
\subsection{Interface}
MGRA server, так же как и mgra tool, работает с двумя форматами представления геномов: GRIMM и INFERCARS.
Пользователь может выбрать, в каком формате он будет вводить информацию и воспользоваться соответствующим пунктом меню. В зависимости от формата, ему будет представлена своя форма для введения информации(см рис). Кнопкой "add genome" можно увеличивать количество геномов. Если же пользователь загружает файл, то сервер сам определит формат, останется ввести только уникальные однобуквенные имена и другие названия геномов.

По кнопке "show tree" пользователь может увидеть в новом окне филогенетические деревья, отрисованные с помощью HTML5 CANVAS. Также можно реконструировать деревья (об этой функции написано ниже). В поле "target" и "completion" он может указать вспомогательную информацию, необходимую для работы mgra tool.

Кроме того, на сайте представлен раздел examples, который призван разрешить возможные вопросы пользователей касаемо ввода информации, работы сервера, а также выходных данных. У каждого примера есть краткое пояснение о входных данных и ссылки на соответсвующие статьи, если пользователь захочет узнать о данном исследовании подробно.
 
\subsection{Web-server} 
Ядро сервера написанно на java с использованием библиотек Jetty для обслуживания запросов пользователя. При нажатии пользователем кнопки run mgra посылается запрос на генерацию данных и отображения их ввиде html. Данные для каждого запроса хранятся в папке, которая соответствует дате и id запроса, например 2011/10/25/request7. В процессе обработки запроса генерируются входные файлы (.cfg и genome.txt), mgra tool запускается отдельным процессом и ожидается его завершение. После этого создается основная страница. На динамическую html-страницу в процессе обработки запроса записывается информация о текущем шаге и возникающих ошибках, а так же всё, что вывел на консоль mgra. Далее происходит десятисекундная задержка, чтобы пользователь успел дочитать инфомацию на странице, и происходит переход к странице с данными.  

\subsection{Visualizer}
MGRA выводит результат в текстовые файлы, а нам нужно представить их в html-формате. Генерация HTML происходит в два этапа: 
\begin{enumerate}
\item Генерируем XML-документ, используя JDOM
\item Выполняем XSLT-преобразование, используя Saxon
\end{enumerate}

\subsection{Tree representation}
Ядром всей визуализации является страница, содержащая поддеревья. 
В первую очередь, здесь пользователь может загрузить входной конфигурационный файл и файл, содержащий исходные геномы, для того чтобы в дальнейшем снова не вводить эти же данные вручную. 
Далее, в секции "Input subtree(s)" представлены (под)деревья, которые ввел пользователь. Cекция "Reconstructed subtree(s)" доступна, если пользователь поставил галочку напротив поля "reconstructed tree". В ней представлены (под)деревья, реконструированные из ветвей, которые находились в файле stats.txt. 

Каждое дерево представляется с помощью HTML5 CANVAS с использованием библиотеки KineticJs. 

Узлы дерева можно перемещать на любое место в области, где отрисовано дерево. Для этого нужно кликнуть интересующий узел и перетащить его в нужное место. 

Помимо этого, пользователь может сохранить дерево в формате .png на своем компьютере. Это можно сделать, нажав кнопку "Save as image". 

Если узел дерева окрашен в темно-голубой цвет, то по двойному клику на него пользователь вызовет ajax-запрос серверу для генерации информации о геноме этой вершины. При этом будет выведено сообщение о том, что запрос обрабатывается. В случае успеха, пользователю будет выдана информация о геноме, в случае неудачи - соответствующее сообщение.

Если же ветвь дерева окрашена в черный цвет, то по двойному клику на нее пользователь вызовет ajax-запрос серверу для генерации трансформации между вершинами. Сообщения в этом случае будут аналогичными.

Для удобства работы с ajax-запросами используется библиотека JQuery. \\

\subsection{Genome representation}
После того как пользователь вызвал соответствующий запрос на генерацию представления генома, MGRA server пытается сгенерировать изображение, но если возникает какая-либо проблема (картинка большая, занимает много памяти и пр.), то сервер пытается сгененировать xml-документ, а потом с помощью XSLT-преобразования создать html-представление. О представлениях геномов в каждой из сиутаций написано ниже.  
\begin{enumerate}
	\item \textbf{Представление в виде изображения}
		\begin{enumerate}
			\item infercars \\
			Плюс этого формата, то что мы знаем длину блоков. Поэтому при отображении в виде изображения мы учитываем разную длину блоков. Но, так как длина такого изображения может быть колоссальна, мы используем следующие трюки:   
			\begin{enumerate}
				\item Находим длину каждого блока в процентах. Это отношение длины блока к длине самой длинной хромосомы.
				\item Полагаем, что p = 0.85\% - это некая константа $c$, задающая минимальный размер блока. При данном проценте большинство изображений еще влезает в допустимые размеры
				\item Все блоки, длина которых меньше значения p, отрисовываем с длиной $c$.
				\item Все блоки, которые больше, маштабируем, в зависимости от длины, в процентах.		
				\item В каждый блок записываем его длину в мега- и кило- величинах. 
			\end{enumerate}
			пример приведен на рисунке 1
			\item grimm \\
			Геном представлен в виде последовательности synteny-блоков. Каждый блок имеет свой номер и ориентацию. Чтобы отображать ориентацию, мы используем пятиугольники, внутри которых записан номер текущего блока.
			пример приведен на рисунке 2.
		\end{enumerate}		
	\item \textbf{Представление в виде html-текста} \\
		Геном представлен в виде последовательности synteny-блоков. Каждый блок имеет свой номер, кроме того, они ориентированы. Если использовать числа для их описания, будет довольно сложно выяснить длину генома или его частей. Поэтому мы используем знаки > и < , в зависимости от их ориентации, для идентифицирования synteny-блоков. Номер блока является заголовком к ссылке на знаки > или < . 	
\end{enumerate}

\subsection{Genome transformation representation}
После того как пользователь вызвал соответствующий запрос на генерацию трансформации генома, MGRA server старается сгенерировать соответствующее представление трансформации. 
Причем сервер знает только информацию о концах разрывов трансформации, поэтому возникает проблема ее восстановления. Решаем следующим образом: 
\begin{enumerate}
	\item Разрезаем хромосому на каждом конце трансформации.
	\item Объединяем части хромосом в местах, где у них совпадают концы.
\end{enumerate}После восстановления трансформации происходит генерация информации по ней в html. Причем напротив каждой перестановки имеется кнопка "Create image\", после нажатия на которую серверу пошлется запрос на замену html-текста на соответвующую картинку.  О представлении трансформации в зависимости от формата изложенно ниже:  
\begin{enumerate}
	\item \textbf{Представление в виде html-текста} \\
		
Пример представления этой трансформации изображен на рисунке 3. 
		Есть две секции, "Before" и "After", отвечающие за хромосомы до и после
 трансформации. Хромосомы имеют такой же вид, как и те, что представлены в виде html при отображении генома.
 
Для обозначения концов хромосом, которые участвуют в перестановке, мы используем буквы h и t. Каждая часть имеет свой цвет, что позволяет нам показать,
 где она находится после перестановки. Мы помечаем тем же цветом соответствующие концы после трансформаций. \\
	\item \textbf{Представление в виде изображения} \\


		Пример представления этой трансформации изображен на рисунке 4.
		Здесь также есть две секции, "Before" и "After", где находятся
 хромосомы до и после трансформации. Хромосомы изображаются так же, как если бы создавалась информация о геноме в виде изображения.  	
		
Куски хромосом, участвующие в перестановке, обводятся прямоугольником определенного цвета, и это позволяет нам показать, где текущие куски находятся после 
трансформации.\\ 
\end{enumerate}


\subsection{Algorithm reconstraction trees}
Так как mgra выдает только ветви в файл stats.txt, нам необходимо найти из них те,
 которые не противоречат входным поддеревьям, а также построить по ним дерево. Мы используем следующий алгоритм: 
\begin{enumerate}
	\item Генерируются
 ветви из входных поддеревьев. 
	\item Считываются возможные ветви из файла stats.txt без учета ветвей, помеченных тегом bf. 
	\item Происходит отбор из 
возможных совместных и наиболее подходящих ветвей. (См. далее)
	\item Если получившиеся множество не пусто, то происходит создание новых поддеревьев 
из этих и сгенерированных из входных поддеревьев ветвей. 
	\item Если получившиеся множество пусто, то 
	\item Удаляются ветви, сгенерированные из
 входных поддеревьев. 
	\item Запускается mgra tool без данных о входных поддеревьях. 
	\item Происходит считывание возможных ветвей из файла stats.txt
 с учетом ветвей, помеченных тегом bf
	\item Происходит отбор из возможных совместных и наиболее подхидящих ветвей. 	
\item На основе множества происходит создание новых поддеревьев.  
\end{enumerate}
Прежде чем говорить о том, как происходит отбор, дадим понятие 
совместных веток: 

две ветки, X+Y и Z+T, совместимы тогда и только тогда, когда одна из частей одной ветки (как множество) является подмножеством или 
надмножеством одной из частей другой ветки. Например, если X - подмножество или
 надмножество либо Z, либо T, то ветки совместимы. \\
\\
Отбор возможных ветвей происходит следующим образом: 

идет полный перебор 
 всех совместимых веток из таблицы и текущего отобранного множества. Качество результируещего множества мы оцениваем из суммарного качества 
выбранных веток (параметр, по которому отсортирована таблица в stats.txt). Так мы находим все подходящие поддеревья, совместимые с данными, и выбираем три
наилучших.  

Сложность этого алгоритма - 2 в степени количества совместимых веток. 

\section{Будущее:}
\begin{enumerate}
	\item Избавиться от ввода уникальных
 имен геномов и начать их генерировать самому. \\
		Проблема в том, что не понятно, как тогда вводить вершины, которые являются предками
 двух или более особей, например: $$((H,R),DOE)$$\\
		Идея решения: отойти от Newick-формата и вершины DOE, представлять в виде:
 $$((human, rat), \{dog, opposum, elefant\})$$
	\item Идея/пожелание, предложенное биологом Ольгой Бочкаревой. \\
		Так как бывает, что вводные 
данные нужно часто менять, хотелось бы иметь личный кабинет для пользователей, чтобы можно было работать со своими загруженными
 данными несколько раз. \\
		Проблема в том, что, я не знаю, как вообще это можно разумно реализовать в виде интерфейса. 
		
Максом Алексеевым была предложена идея загружать cfg-файл, но это спасает нас частично и только на первое время. Так как в результате весь интерфейс оказывается
 не нужен, и пользователь начинает работать только с текстовым файлом, 	периодически загружая его на сервер. Однако,возможность загрузки cfg-файла так же 
необходимо реализовать. 
	\item Тестирование сервера. Ольга Бочкарова обещала предоставить 4(+1 под вопросом) набора входных данных для сервера и алгоритма. 
	\item Какие-то другие изменения о которых я не знаю.    
\end{enumerate}
\end{document}
